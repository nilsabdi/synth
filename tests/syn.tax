comments

	/* block */
	// line


variables

	typed: type = expr
	infer := expr
	destruct1, destruct2, ... := ( 1, 2, ... ) // tuple


functions/lambdas

	(param: type, ...) -> ret {}
	(param: type, ...) -> { expr } // only expression
	foo: (param: type, ...) -> ret {}
	foo: (param: type, ...) -> { expr }
	return expr


types

	str: struct 	<T> { field: type, ... }
	enu: enum 		<T> { item: type, item, ... }
	tup: struct		<T> ( type, ... ) 					// tuple struct
	tra: trait 		<T> { method: () {} }
	str: impl 		<T> { method: () {} } 				// method for struct
	str: impl tra 	<T> { method: () {} } 				/* trait impl */


generic bounds

	< T: trait + ..., Y: ... >


flow

	match expr {
		case { expr }
		_ { expr } // default
	}

	alias: loop item = iter {} /* for iter loop */
	alias: loop <condition> {} /* while loop */
	alias: loop {} 				/* infinite loop */
	break alias
	skip alias


modules

	with module
	with module.{symbol, ...}


/* ------- keywords ---------- */

	loop struct enum trait impl with match skip break return


/* --------- rules ----------- */

- main entrypoint
- incremental compile
- imports are cached


/* -------- examples --------- */
main: () -> i32
{
	loop i = range(10)
	{
		print(i)
	}
}
/*
int main () {
	{
		typeof(range(10)) __iter = range(10);
		typeof(__iter()) i;

		while ((i = __iter())) {
			printf("{}", i);
		}
	}
}
*/


a := 0
loop a < 5 {
	print(a += 1)
}

/*
int a = 0;

{
	while (a < 5) {
		printf("{}", (a+=1));
	}
}
*/


fac: (n: i32) -> { n > 2 && n * fac(n - 1) || 2 }

facgen: (n: i32) -> () -> i32 {
	m := 0
	return () -> { m < n && fac(m += 1) || 0 }
}
